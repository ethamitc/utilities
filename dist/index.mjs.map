{"version":3,"file":"index.mjs","sources":["../src/lib/type-guards.ts","../src/lib/PaginatedMessage.ts","../src/lib/LazyPaginatedMessage.ts"],"sourcesContent":["import type {\n\tCategoryChannel,\n\tChannel,\n\tDMChannel,\n\tGuildChannel,\n\tNewsChannel,\n\tPartialGroupDMChannel,\n\tStoreChannel,\n\tTextChannel,\n\tVoiceChannel\n} from 'discord.js';\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/CategoryChannel CategoryChannel}\n * @param channel The channel to check\n */\nexport function isCategoryChannel(channel: Channel): channel is CategoryChannel {\n\treturn channel.type === 'category';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/DMChannel DMChannel}\n * @param channel The channel to check\n */\nexport function isDMChannel(channel: Channel): channel is DMChannel {\n\treturn channel.type === 'dm';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/PartialGroupDMChannel PartialGroupDMChannel}\n * @param channel The channel to check\n */\nexport function isGroupChannel(channel: Channel): channel is PartialGroupDMChannel {\n\treturn channel.type === 'group';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/GuildChannel GuildChannel}\n * @param channel The channel to check\n */\nexport function isGuildBasedChannel(channel: Channel): channel is GuildChannel {\n\treturn channel.type !== 'dm' && channel.type !== 'group' && channel.type !== 'unknown';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/NewsChannel NewsChannel}\n * @param channel The channel to check\n */\nexport function isNewsChannel(channel: Channel): channel is NewsChannel {\n\treturn channel.type === 'news';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/StoreChannel StoreChannel}\n * @param channel The channel to check\n */\nexport function isStoreChannel(channel: Channel): channel is StoreChannel {\n\treturn channel.type === 'store';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/TextChannel TextChannel}\n * @param channel The channel to check\n */\nexport function isTextChannel(channel: Channel): channel is TextChannel {\n\treturn channel.type === 'text';\n}\n\n/**\n * Checks whether a given channel is a {@link https://discord.js.org/#/docs/main/stable/class/VoiceChannel VoiceChannel}\n * @param channel The channel to check\n */\nexport function isVoiceChannel(channel: Channel): channel is VoiceChannel {\n\treturn channel.type === 'voice';\n}\n","import type { APIMessage, Message, MessageReaction, NewsChannel, ReactionCollector, TextChannel, User } from 'discord.js';\n\n/**\n * This is a [[PaginatedMessage]], a utility to paginate messages (usually embeds).\n * You must either use this class directly or extend it.\n *\n * [[PaginatedMessage]] uses actions, these are essentially reaction emojis, when triggered run the said action.\n * You can utilize your own actions, or you can use the [[PaginatedMessage.defaultActions]].\n * [[PaginatedMessage.defaultActions]] is also static so you can modify these directly.\n *\n * [[PaginatedMessage]] also uses pages, these are simply {@link https://discord.js.org/#/docs/main/stable/class/APIMessage APIMessages}.\n *\n * @example\n * ```typescript\n * const handler = new PaginatedMessage();\n * ```\n *\n * @example\n * ```typescript\n * // To utilize actions you can use the IPaginatedMessageAction by implementing it into a class.\n * // [[PaginatedMessage]] requires you to have the class initialized using `new`.\n *\n * class ForwardAction implements IPaginatedMessageAction {\n *   public id = 'â–¶ï¸';\n *\n *   public run({ handler }) {\n *     if (handler.index !== handler.pages.length - 1) ++handler.index;\n *   }\n * }\n *\n * // You can also give the object directly.\n *\n * const StopAction: IPaginatedMessageAction {\n *   id: 'â¹ï¸',\n *   disableResponseEdit: true,\n *   run: ({ response, collector }) => {\n *     await response!.reactions.removeAll();\n *     collector!.stop();\n *   }\n * }```\n *\n */\nexport class PaginatedMessage {\n\t/**\n\t * The pages to be converted to [[PaginatedMessage.messages]]\n\t */\n\tpublic pages: MessagePage[];\n\n\t/**\n\t * The response message used to edit on page changes.\n\t */\n\tpublic response: Message | null = null;\n\n\t/**\n\t * The collector used for handling reactions.\n\t */\n\tpublic collector: ReactionCollector | null = null;\n\n\t/**\n\t * The pages which were converted from [[PaginatedMessage.pages]]\n\t */\n\tpublic messages: (APIMessage | null)[] = [];\n\n\t/**\n\t * The actions which are to be used.\n\t */\n\tpublic actions = new Map<string, IPaginatedMessageAction>();\n\n\t/**\n\t * The handler's current page/message index.\n\t */\n\tpublic index = 0;\n\n\t/**\n\t * The amount of time to idle before the paginator is closed. Defaults to `20 * 1000`.\n\t */\n\tpublic idle = 20 * 1000;\n\n\t/**\n\t * Constructor for the [[PaginatedMessage]] class\n\t * @param __namedParameters The [[PaginatedMessageOptions]] for this instance of the [[PaginatedMessage]] class\n\t */\n\tpublic constructor({ pages, actions = PaginatedMessage.defaultActions }: PaginatedMessageOptions = {}) {\n\t\tthis.pages = pages ?? [];\n\n\t\tfor (const page of this.pages) this.messages.push(typeof page === 'function' ? null : page);\n\t\tfor (const action of actions) this.actions.set(action.id, action);\n\t}\n\n\t/**\n\t * Sets the handler's current page/message index.\n\t * @param index The number to set the index to.\n\t */\n\tpublic setIndex(index: number) {\n\t\tthis.index = index;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the amount of time to idle before the paginator is closed.\n\t * @param idle The number to set the idle to.\n\t */\n\tpublic setIdle(idle: number) {\n\t\tthis.idle = idle;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clears all current actions and sets them. The order given is the order they will be used.\n\t * @param actions The actions to set.\n\t */\n\tpublic setActions(actions: IPaginatedMessageAction[]) {\n\t\tthis.actions.clear();\n\t\treturn this.addActions(actions);\n\t}\n\n\t/**\n\t * Adds actions to the existing ones. The order given is the order they will be used.\n\t * @param actions The actions to add.\n\t */\n\tpublic addActions(actions: IPaginatedMessageAction[]) {\n\t\tfor (const action of actions) this.addAction(action);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds an action to the existing ones. This will be added as the last action.\n\t * @param action The action to add.\n\t */\n\tpublic addAction(action: IPaginatedMessageAction) {\n\t\tthis.actions.set(action.id, action);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clears all current pages and messages and sets them. The order given is the order they will be used.\n\t * @param pages The pages to set.\n\t */\n\tpublic setPages(pages: MessagePage[]) {\n\t\tthis.pages = [];\n\t\tthis.messages = [];\n\t\tthis.addPages(pages);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add pages to the existing ones. The order given is the order they will be used.\n\t * @param pages The pages to add.\n\t */\n\tpublic addPages(pages: MessagePage[]) {\n\t\tfor (const page of pages) this.addPage(page);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a page to the existing ones. This will be added as the last page.\n\t * @param page The page to add.\n\t */\n\tpublic addPage(page: MessagePage) {\n\t\tthis.pages.push(page);\n\t\tthis.messages.push(typeof page === 'function' ? null : page);\n\t\treturn this;\n\t}\n\n\t/**\n\t * This executes the [[PaginatedMessage]] and sends the pages corresponding with [[PaginatedMessage.index]].\n\t * The handler will start collecting reactions and running actions once all actions have been reacted to the message.\n\t * @param author The author to validate.\n\t * @param channel The channel to use.\n\t */\n\tpublic async run(author: User, channel: TextChannel | NewsChannel) {\n\t\tawait this.resolvePagesOnRun();\n\n\t\tif (!this.messages.length) throw new Error('There are no messages.');\n\t\tif (!this.actions.size) throw new Error('There are no messages.');\n\n\t\tconst firstPage = this.messages[this.index]!;\n\n\t\tthis.response ??= (await channel.send(firstPage)) as Message;\n\n\t\tfor (const id of this.actions.keys()) await this.response.react(id);\n\n\t\tthis.collector ??= this.response\n\t\t\t.createReactionCollector(\n\t\t\t\t(reaction: MessageReaction, user: User) =>\n\t\t\t\t\t(this.actions.has(reaction.emoji.identifier) || this.actions.has(reaction.emoji.name)) && user.id === author.id,\n\t\t\t\t{ idle: this.idle }\n\t\t\t)\n\t\t\t.on('collect', this.handleCollect.bind(this, author, channel))\n\t\t\t.on('end', this.handleEnd.bind(this));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * This function is executed on [[PaginatedMessage.run]]. This is an extendable method.\n\t */\n\tpublic async resolvePagesOnRun() {\n\t\tfor (let i = 0; i < this.pages.length; i++) await this.resolvePage(i);\n\t}\n\n\t/**\n\t * This function is executed whenever an action is triggered and resolved.\n\t * @param index The index to resolve.\n\t */\n\tpublic async resolvePage(index: number = this.index) {\n\t\tconst page = this.pages[index];\n\t\t// @ts-expect-error 2349\n\t\tif (page) this.messages[index] ??= await this.pages[index](index, this.pages, this);\n\t\treturn this.messages[index];\n\t}\n\n\t/**\n\t * This clones the current handler into a new instance.\n\t */\n\tpublic clone() {\n\t\tconst clone = new PaginatedMessage({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);\n\t\tclone.actions = this.actions;\n\t\tclone.response = this.response;\n\t\tclone.collector = this.collector;\n\t\treturn clone;\n\t}\n\n\tprotected async handleCollect(author: User, channel: TextChannel | NewsChannel, reaction: MessageReaction, user: User) {\n\t\tawait reaction.users.remove(user);\n\n\t\tconst action = (this.actions.get(reaction.emoji.identifier) ?? this.actions.get(reaction.emoji.name))!;\n\t\tconst previousIndex = this.index;\n\n\t\tawait action.run({\n\t\t\thandler: this,\n\t\t\tauthor,\n\t\t\tchannel,\n\t\t\tresponse: this.response!,\n\t\t\tcollector: this.collector!\n\t\t});\n\n\t\tif (previousIndex !== this.index) {\n\t\t\tawait this.response?.edit((await this.resolvePage())!);\n\t\t}\n\t}\n\n\tprotected async handleEnd(reason: string) {\n\t\t// Remove all listeners from the collector:\n\t\tif (this.collector) {\n\t\t\tthis.collector.removeAllListeners();\n\t\t\tthis.collector = null;\n\t\t}\n\n\t\t// Do not remove reactions if the message, channel, or guild, was deleted:\n\t\tif (this.response && !PaginatedMessage.deletionStopReasons.includes(reason)) {\n\t\t\tawait this.response.reactions.removeAll();\n\t\t}\n\t}\n\n\t/**\n\t * The default actions of this handler.\n\t */\n\tpublic static defaultActions: IPaginatedMessageAction[] = [\n\t\t{\n\t\t\tid: 'ðŸ”¢',\n\t\t\trun: async ({ handler, author, channel }) => {\n\t\t\t\tconst questionMessage = await channel.send('What page would you like to jump to?');\n\t\t\t\tconst collected = await channel\n\t\t\t\t\t.awaitMessages((message: Message) => message.author.id === author.id, { max: 1, idle: 15 * 1000 })\n\t\t\t\t\t.catch(() => null);\n\n\t\t\t\tif (collected) {\n\t\t\t\t\tconst responseMessage = collected.first();\n\n\t\t\t\t\tif (questionMessage.deletable) await questionMessage.delete();\n\t\t\t\t\tif (responseMessage) {\n\t\t\t\t\t\tif (responseMessage.deletable) await responseMessage.delete();\n\n\t\t\t\t\t\tconst i = Number(responseMessage.content) - 1;\n\n\t\t\t\t\t\tif (!isNaN(i) && handler.pages[i]) handler.index = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 'âª',\n\t\t\trun: ({ handler }) => (handler.index = 0)\n\t\t},\n\t\t{\n\t\t\tid: 'â—€ï¸',\n\t\t\trun: ({ handler }) => {\n\t\t\t\tif (handler.index !== 0) --handler.index;\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 'â–¶ï¸',\n\t\t\trun: ({ handler }) => {\n\t\t\t\tif (handler.index !== handler.pages.length - 1) ++handler.index;\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 'â©',\n\t\t\trun: ({ handler }) => (handler.index = handler.pages.length - 1)\n\t\t},\n\t\t{\n\t\t\tid: 'â¹ï¸',\n\t\t\trun: async ({ response, collector }) => {\n\t\t\t\tawait response.reactions.removeAll();\n\t\t\t\tcollector.stop();\n\t\t\t}\n\t\t}\n\t];\n\n\t/**\n\t * The reasons sent by {@link https://discord.js.org/#/docs/main/stable/class/ReactionCollector?scrollTo=e-end ReactionCollector#end}\n\t * event when the message (or its owner) has been deleted.\n\t */\n\tpublic static deletionStopReasons = ['messageDelete', 'channelDelete', 'guildDelete'];\n}\n\n/**\n * @example\n * ```typescript\n * // To utilize actions you can use the [[IPaginatedMessageAction]] by implementing it into a class.\n *\n * class ForwardAction implements IPaginatedMessageAction {\n *   public id = 'â–¶ï¸';\n *\n *   public run({ handler }) {\n *     if (handler.index !== handler.pages.length - 1) ++handler.index;\n *   }\n * }\n *\n * // You can also give the object directly.\n *\n * const StopAction: IPaginatedMessageAction {\n *   id: 'â¹ï¸',\n *   disableResponseEdit: true,\n *   run: ({ response, collector }) => {\n *     await response!.reactions.removeAll();\n *     collector!.stop();\n *   }\n * }```\n */\nexport interface IPaginatedMessageAction {\n\tid: string;\n\trun(context: PaginatedMessageActionContext): Awaited<unknown>;\n}\n\n/**\n * The context to be used in [[IPaginatedMessageAction]].\n */\nexport interface PaginatedMessageActionContext {\n\thandler: PaginatedMessage;\n\tauthor: User;\n\tchannel: TextChannel | NewsChannel;\n\tresponse: Message;\n\tcollector: ReactionCollector;\n}\n\nexport interface PaginatedMessageOptions {\n\tpages?: MessagePage[];\n\tactions?: IPaginatedMessageAction[];\n}\n\n/**\n * The pages that are used for [[PaginatedMessage.pages]]\n *\n * Pages can be either an {@link https://discord.js.org/#/docs/main/stable/class/APIMessage APIMessage} directly,\n * or an awaited function which returns an {@link https://discord.js.org/#/docs/main/stable/class/APIMessage APIMessage}.\n *\n * @example\n * ```typescript\n * // Direct usage as an APIMessage\n *\n * new APIMessage(message.channel, {\n *   context: 'Test content!',\n * });\n *\n * // An awaited function. This function also passes index, pages, and handler.\n *\n * (index, pages) =>\n *   new APIMessage(message.channel, {\n *     embed: new MessageEmbed().setFooter(`Page ${index + 1} / ${pages.length}`)\n *   });\n * ```\n */\nexport type MessagePage = ((index: number, pages: MessagePage[], handler: PaginatedMessage) => Awaited<APIMessage>) | APIMessage;\n\ntype Awaited<T> = PromiseLike<T> | T;\n","import { PaginatedMessage } from './PaginatedMessage';\n\n/**\n * This is a LazyPaginatedMessage. Instead of resolving all pages that are functions on [[PaginatedMessage.run]] will resolve when requested.\n */\nexport class LazyPaginatedMessage extends PaginatedMessage {\n\t/**\n\t * Only resolves the page corresponding with the handler's current index.\n\t */\n\tpublic async resolvePagesOnStart() {\n\t\tawait this.resolvePage(this.index);\n\t}\n\n\t/**\n\t * Resolves the page corresponding with the given index. This also resolves the index's before and after the given index.\n\t * @param index The index to resolve. Defaults to handler's current index.\n\t */\n\tpublic async resolvePage(index: number = this.index) {\n\t\tawait super.resolvePage(index - 1);\n\t\tawait super.resolvePage(index + 1);\n\n\t\treturn super.resolvePage(index);\n\t}\n}\n"],"names":["isCategoryChannel","channel","type","isDMChannel","isGroupChannel","isGuildBasedChannel","isNewsChannel","isStoreChannel","isTextChannel","isVoiceChannel","PaginatedMessage","[object Object]","pages","actions","defaultActions","Object","Map","this","page","messages","push","action","set","id","index","idle","clear","addActions","addAction","addPages","addPage","author","resolvePagesOnRun","length","Error","size","firstPage","response","send","keys","react","collector","createReactionCollector","reaction","user","has","emoji","identifier","name","on","handleCollect","bind","handleEnd","i","resolvePage","clone","setIndex","setIdle","users","remove","get","previousIndex","run","handler","edit","reason","removeAllListeners","deletionStopReasons","includes","reactions","removeAll","async","questionMessage","collected","awaitMessages","message","max","catch","responseMessage","first","deletable","delete","Number","content","isNaN","stop","LazyPaginatedMessage","super"],"mappings":"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"}